"use client";

import * as React from "react";
import { supabase } from "@/utils/supabase/client";
import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "@/app/types/database";

export type Channel = "email" | "text" | "card";
export type Relationship = "friend" | "family" | "coworker" | "other";
export type Tone = "warm" | "formal" | "playful";

export type Reminder = {
  id: string;
  listId: string;
  giftId: string;
  dueAt: string;
  channel: Channel;
  sent: boolean;
  createdAt: string;
  giftSnapshot: {
    guestName: string;
    description: string;
    date: string;
  };
};

export type Draft = {
  id: string;
  listId: string;
  giftId: string;
  channel: Channel;
  content: string;
  relationship: Relationship;
  tone: Tone;
  updatedAt: string;
};

export type ReminderSettings = {
  defaultIntervalsDays: number[];
  defaultChannel: Channel;
  autoGenerateDrafts: boolean;
  timezone: string;
};

type GiftLike = {
  id: string;
  guestName: string;
  description: string;
  date: string;
};

type State = {
  settingsByList: Record<string, ReminderSettings>;
  reminders: Reminder[];
  drafts: Draft[];
};

type Ctx = {
  getListSettings: (listId: string) => ReminderSettings;
  setListSettings: (listId: string, settings: ReminderSettings) => void;
  scheduleForGift: (listId: string, gift: GiftLike, options?: Partial<{
    intervalsDays: number[];
    channel: Channel;
    autoGenerateDrafts: boolean;
    relationship: Relationship;
    tone: Tone;
  }>) => void;
  getRemindersForList: (listId: string) => Reminder[];
  getAllRemindersForList: (listId: string, options?: { includeSent?: boolean }) => Reminder[];
  rescheduleReminder: (reminderId: string, newDueYmd: string) => void;
  markManyDone: (reminderIds: string[]) => void;
  deleteMany: (reminderIds: string[]) => void;
  markReminderDone: (reminderId: string) => void;
  setReminderSent: (reminderId: string, sent: boolean) => void;
  deleteReminder: (reminderId: string) => void;
  getDraftsForGift: (giftId: string) => Draft[];
  upsertDraft: (draft: Omit<Draft, "id" | "updatedAt"> & { id?: string }) => string;
  hydrateListReminders: (listId: string) => Promise<void>;
  hydrateListSettings: (listId: string) => Promise<void>;
  createReminders: (
    listId: string,
    gift: GiftLike,
    datesYmd: string[],
    options?: Partial<{ channel: Channel; autoGenerateDrafts: boolean; relationship: Relationship; tone: Tone }>
  ) => Promise<void>;
};

const STORAGE_KEY = "thankarooRemindersV1";
const ReminderContext = React.createContext<Ctx | undefined>(undefined);

const genId = () =>
  typeof crypto !== "undefined" && "randomUUID" in crypto
    ? crypto.randomUUID()
    : Math.random().toString(36).slice(2, 9);

const DEFAULT_SETTINGS: ReminderSettings = {
  defaultIntervalsDays: [7, 14],
  defaultChannel: "email",
  autoGenerateDrafts: true,
  timezone: "UTC",
};

function addDays(baseYmd: string, days: number) {
  const d = new Date(baseYmd + "T00:00:00Z");
  d.setUTCDate(d.getUTCDate() + days);
  return d.toISOString().slice(0, 10);
}

export function ReminderProvider({ children }: { children: React.ReactNode }) {
  const supa = supabase as unknown as SupabaseClient<Database>;
  const [state, setState] = React.useState<State>({ settingsByList: {}, reminders: [], drafts: [] });

  // Hydrate from localStorage after mount to avoid SSR/client mismatch
  React.useEffect(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const parsed = JSON.parse(raw) as State;
        setState(parsed);
      }
    } catch {}
  }, []);

  React.useEffect(() => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch {}
  }, [state]);

  const getListSettings = React.useCallback(
    (listId: string): ReminderSettings => {
      return state.settingsByList[listId] ?? DEFAULT_SETTINGS;
    },
    [state.settingsByList]
  );

  const setListSettings = React.useCallback(
    (listId: string, settings: ReminderSettings) => {
      setState((prev) => ({
        ...prev,
        settingsByList: { ...prev.settingsByList, [listId]: settings },
      }));
      void (async () => {
        try {
          await supa
            .from("reminder_settings")
            .upsert(
              {
                list_id: listId,
                default_intervals_days: settings.defaultIntervalsDays,
                default_channel: settings.defaultChannel,
                auto_generate_drafts: settings.autoGenerateDrafts,
                timezone: settings.timezone,
              } as Database["public"]["Tables"]["reminder_settings"]["Insert"],
              { onConflict: "list_id" }
            );
        } catch {}
      })();
    },
    []
  );

  const scheduleForGift = React.useCallback(
    (
      listId: string,
      gift: GiftLike,
      options?: Partial<{
        intervalsDays: number[];
        channel: Channel;
        autoGenerateDrafts: boolean;
        relationship: Relationship;
        tone: Tone;
      }>
    ) => {
      const settings = getListSettings(listId);
      const intervals = options?.intervalsDays ?? settings.defaultIntervalsDays;
      const channel = options?.channel ?? settings.defaultChannel;
      const autoGenerate = options?.autoGenerateDrafts ?? settings.autoGenerateDrafts;

      const newReminders: Reminder[] = intervals.map((days) => ({
        id: genId(),
        listId,
        giftId: gift.id,
        dueAt: addDays(gift.date, days),
        channel,
        sent: false,
        createdAt: new Date().toISOString(),
        giftSnapshot: {
          guestName: gift.guestName,
          description: gift.description,
          date: gift.date,
        },
      }));

      setState((prev) => ({
        ...prev,
        reminders: [...prev.reminders, ...newReminders],
      }));

      void (async () => {
        try {
          const rows = newReminders.map((r) => ({
            id: r.id,
            list_id: r.listId,
            gift_id: r.giftId,
            due_at: r.dueAt,
            channel: r.channel,
            sent: r.sent,
            created_at: r.createdAt,
            gift_snapshot: r.giftSnapshot,
          }));
          await supa
            .from("reminders")
            .insert(rows as Database["public"]["Tables"]["reminders"]["Insert"][]);
        } catch {}
      })();

      if (autoGenerate) {
        const existing = state.drafts.find(
          (d) => d.giftId === gift.id && d.channel === channel
        );
        if (!existing) {
          setState((prev) => ({
            ...prev,
            drafts: [
              ...prev.drafts,
              {
                id: genId(),
                listId,
                giftId: gift.id,
                channel,
                content: "",
                relationship: options?.relationship ?? "friend",
                tone: options?.tone ?? "warm",
                updatedAt: new Date().toISOString(),
              },
            ],
          }));
        }
      }
    },
    [getListSettings, state.drafts]
  );

  const getRemindersForList = React.useCallback(
    (listId: string) => {
      return state.reminders
        .filter((r) => r.listId === listId && !r.sent)
        .sort((a, b) => a.dueAt.localeCompare(b.dueAt));
    },
    [state.reminders]
  );

  const getAllRemindersForList = React.useCallback(
    (listId: string, options?: { includeSent?: boolean }) => {
      const includeSent = options?.includeSent ?? true;
      return state.reminders
        .filter((r) => r.listId === listId && (includeSent || !r.sent))
        .sort((a, b) => a.dueAt.localeCompare(b.dueAt));
    },
    [state.reminders]
  );

  const rescheduleReminder = React.useCallback((reminderId: string, newDueYmd: string) => {
    setState((prev) => ({
      ...prev,
      reminders: prev.reminders.map((r) => (r.id === reminderId ? { ...r, dueAt: newDueYmd } : r)),
    }));
    void (async () => {
      try {
        await supa
          .from("reminders")
          .update({ due_at: newDueYmd } as Database["public"]["Tables"]["reminders"]["Update"]) 
          .eq("id", reminderId);
      } catch {}
    })();
  }, []);

  const markManyDone = React.useCallback((reminderIds: string[]) => {
    if (reminderIds.length === 0) return;
    const setIds = new Set(reminderIds);
    setState((prev) => ({
      ...prev,
      reminders: prev.reminders.map((r) => (setIds.has(r.id) ? { ...r, sent: true } : r)),
    }));
    void (async () => {
      try {
        await supa
          .from("reminders")
          .update({ sent: true } as Database["public"]["Tables"]["reminders"]["Update"]) 
          .in("id", reminderIds);
      } catch {}
    })();
  }, []);

  const deleteMany = React.useCallback((reminderIds: string[]) => {
    if (reminderIds.length === 0) return;
    const setIds = new Set(reminderIds);
    setState((prev) => ({
      ...prev,
      reminders: prev.reminders.filter((r) => !setIds.has(r.id)),
    }));
    void (async () => {
      try {
        await supa.from("reminders").delete().in("id", reminderIds);
      } catch {}
    })();
  }, []);

  const markReminderDone = React.useCallback((reminderId: string) => {
    setState((prev) => ({
      ...prev,
      reminders: prev.reminders.map((r) =>
        r.id === reminderId ? { ...r, sent: true } : r
      ),
    }));
    void (async () => {
      try {
        await supa
          .from("reminders")
          .update({ sent: true } as Database["public"]["Tables"]["reminders"]["Update"]) 
          .eq("id", reminderId);
      } catch {}
    })();
  }, []);

  const setReminderSent = React.useCallback((reminderId: string, sent: boolean) => {
    setState((prev) => ({
      ...prev,
      reminders: prev.reminders.map((r) => (r.id === reminderId ? { ...r, sent } : r)),
    }));
    void (async () => {
      try {
        await supa
          .from("reminders")
          .update({ sent } as Database["public"]["Tables"]["reminders"]["Update"]) 
          .eq("id", reminderId);
      } catch {}
    })();
  }, []);

  const deleteReminder = React.useCallback((reminderId: string) => {
    setState((prev) => ({
      ...prev,
      reminders: prev.reminders.filter((r) => r.id !== reminderId),
    }));
    void (async () => {
      try {
        await supa.from("reminders").delete().eq("id", reminderId);
      } catch {}
    })();
  }, []);

  const getDraftsForGift = React.useCallback(
    (giftId: string) => state.drafts.filter((d) => d.giftId === giftId),
    [state.drafts]
  );

  const upsertDraft = React.useCallback(
    (draft: Omit<Draft, "id" | "updatedAt"> & { id?: string }) => {
      const now = new Date().toISOString();
      const id = draft.id ?? genId();
      setState((prev) => {
        const exists = prev.drafts.some((d) => d.id === id);
        return {
          ...prev,
          drafts: exists
            ? prev.drafts.map((d) => (d.id === id ? { ...d, ...draft, id, updatedAt: now } : d))
            : [...prev.drafts, { ...draft, id, updatedAt: now }],
        };
      });
      return id;
    },
    []
  );

  const value: Ctx = {
    getListSettings,
    setListSettings,
    scheduleForGift,
    getRemindersForList,
    getAllRemindersForList,
    rescheduleReminder,
    markManyDone,
    deleteMany,
    markReminderDone,
    deleteReminder,
    getDraftsForGift,
    upsertDraft,
    hydrateListReminders: async (listId: string) => {
      try {
        const { data, error } = await supa
          .from("reminders")
          .select("id, list_id, gift_id, due_at, channel, sent, created_at, gift_snapshot")
          .eq("list_id", listId)
          .order("due_at", { ascending: true });
        if (error || !data) return;
        const mapped: Reminder[] = data.map((row) => ({
          id: row.id,
          listId: row.list_id,
          giftId: row.gift_id,
          dueAt: row.due_at,
          channel: row.channel as Channel,
          sent: row.sent,
          createdAt: row.created_at,
          giftSnapshot: row.gift_snapshot as Reminder["giftSnapshot"],
        }));
        setState((prev) => ({
          ...prev,
          reminders: [
            ...prev.reminders.filter((r) => r.listId !== listId),
            ...mapped,
          ],
        }));
      } catch {}
    },
    hydrateListSettings: async (listId: string) => {
      try {
        const { data, error } = await supa
          .from("reminder_settings")
          .select("list_id, default_intervals_days, default_channel, auto_generate_drafts, timezone")
          .eq("list_id", listId)
          .maybeSingle();
        if (error || !data) return;
        const settings: ReminderSettings = {
          defaultIntervalsDays: data.default_intervals_days ?? DEFAULT_SETTINGS.defaultIntervalsDays,
          defaultChannel: (data.default_channel as Channel) ?? DEFAULT_SETTINGS.defaultChannel,
          autoGenerateDrafts: data.auto_generate_drafts ?? DEFAULT_SETTINGS.autoGenerateDrafts,
          timezone: data.timezone ?? DEFAULT_SETTINGS.timezone,
        };
        setState((prev) => ({
          ...prev,
          settingsByList: { ...prev.settingsByList, [listId]: settings },
        }));
      } catch {}
    },
    createReminders: async (
      listId: string,
      gift: GiftLike,
      datesYmd: string[],
      options?: Partial<{ channel: Channel; autoGenerateDrafts: boolean; relationship: Relationship; tone: Tone }>
    ) => {
      const settings = getListSettings(listId);
      const channel = options?.channel ?? settings.defaultChannel;
      const autoGenerate = options?.autoGenerateDrafts ?? settings.autoGenerateDrafts;

      const toCreate: Reminder[] = datesYmd.map((d) => ({
        id: genId(),
        listId,
        giftId: gift.id,
        dueAt: d,
        channel,
        sent: false,
        createdAt: new Date().toISOString(),
        giftSnapshot: { guestName: gift.guestName, description: gift.description, date: gift.date },
      }));

      setState((prev) => ({ ...prev, reminders: [...prev.reminders, ...toCreate] }));

      try {
        const rows = toCreate.map((r) => ({
          id: r.id,
          list_id: r.listId,
          gift_id: r.giftId,
          due_at: r.dueAt,
          channel: r.channel,
          sent: r.sent,
          created_at: r.createdAt,
          gift_snapshot: r.giftSnapshot,
        }));
        await supa
          .from("reminders")
          .insert(rows as Database["public"]["Tables"]["reminders"]["Insert"][]);
      } catch {}

      if (autoGenerate) {
        const exists = state.drafts.find((d) => d.giftId === gift.id && d.channel === channel);
        if (!exists) {
          setState((prev) => ({
            ...prev,
            drafts: [
              ...prev.drafts,
              {
                id: genId(),
                listId,
                giftId: gift.id,
                channel,
                content: "",
                relationship: options?.relationship ?? "friend",
                tone: options?.tone ?? "warm",
                updatedAt: new Date().toISOString(),
              },
            ],
          }));
        }
      }
    },
    setReminderSent,
  };

  return <ReminderContext.Provider value={value}>{children}</ReminderContext.Provider>;
}

export function useReminders() {
  const ctx = React.useContext(ReminderContext);
  if (!ctx) throw new Error("useReminders must be used within ReminderProvider");
  return ctx;
}